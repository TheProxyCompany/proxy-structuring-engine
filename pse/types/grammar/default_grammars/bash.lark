////////////////////////////
// Bash Grammar for Lark
//
// A comprehensive grammar for parsing Bash scripts
// Version: 1.0
////////////////////////////

//------------------------------------------------------
// Ignore rules
//------------------------------------------------------
%ignore /[ \t]+/        // Ignore horizontal whitespace
%ignore /\\(\r?\n)+/    // Handle backslash-newline continuations
%ignore COMMENT         // Ignore comments

//------------------------------------------------------
// Basic Tokens
//------------------------------------------------------
NEWLINE: /\r?\n+/
COMMENT: /#[^\n]*/

// Character Classes
LETTER: "a".."z" | "A".."Z"
DIGIT: "0".."9"

// Numbers
INT: DIGIT+
number: INT

//------------------------------------------------------
// Keywords and Reserved Words
//------------------------------------------------------
// Control Flow Keywords
IF: "if"
THEN: "then"
ELSE: "else"
ELIF: "elif"
FI: "fi"
FOR: "for"
WHILE: "while"
UNTIL: "until"
DO: "do"
DONE: "done"
IN: "in"
CASE: "case"
ESAC: "esac"
SELECT: "select"
FUNCTION: "function"
TIME: "time"

//------------------------------------------------------
// Operators and Delimiters
//------------------------------------------------------
// Parentheses, Braces, Brackets
LPAR: "("
RPAR: ")"
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"

// Separators and Terminators
SEMICOLON: ";"
DOUBLE_SEMICOLON: ";;"
COLON: ":"
COMMA: ","

// Operators
AMPERSAND: "&"
VBAR: "|"
LOGICAL_AND: "&&"       // Added logical AND operator
LOGICAL_OR: "||"        // Added logical OR operator
BANG: "!"
MORETHAN: ">"
LESSTHAN: "<"
EQUAL: "="
PLUS: "+"
MINUS: "-"
DOT: "."
SLASH: "/"
AT: "@"
TILDE: "~"
UNDERSCORE: "_"

//------------------------------------------------------
// Word-like Tokens
//------------------------------------------------------
word: WORD
WORD: /[a-zA-Z_][a-zA-Z0-9_\-\.\/:\+@=~]*/
    | /\-[a-zA-Z0-9_\-\.\/:\+@=~]+/
    | /\/[a-zA-Z0-9_\-\.\/:\+@=~]+/

STRING: /'[^']*'/      // Fixed single-quoted string
      | /"[^"]*"/      // Fixed double-quoted string

// Shell variable references
VARIABLE: "$" (LETTER | DIGIT | UNDERSCORE | "{" /[^}]*/ "}")?
        | "$" /[a-zA-Z0-9_]+/
        | "$" /[a-zA-Z0-9_]+/(":" /[a-zA-Z0-9_\/\.]+/)?

// Command substitution and expressions
CMD_SUBST.2: /\$\([^()]*\)/
ARITH_EXPR: "$((" /[^)]*/ "))"?    // Can't handle nested
          | "((" /[^)]*/ "))"?     // Alternate arithmetic expression ((...))
TEST_EXPR: LBRACKET /[^]]*/ RBRACKET?  // Test expression [ ... ]
         | "[[" /[^]]*/ "]]"?      // Extended test expression [[ ... ]]
FD: /[0-9]+/                       // File descriptor

//------------------------------------------------------
// Script Structure
//------------------------------------------------------
start: script
script: (COMMENT | pipeline_command | separator)+
       |  // empty (optional)

//------------------------------------------------------
// Command Structure
//------------------------------------------------------
?command: (simple_command | shell_command) redirection_list?

//------------------------------------------------------
// Redirection
//------------------------------------------------------
?redirection: redirect_op word
            | FD? redirect_op word
            | FD? redirect_op FD
            | FD? MORETHAN MORETHAN word        // Append redirection >>

// Redirection operators
!redirect_op: ">"       // Output redirection
             | "<"      // Input redirection
             | ">>"     // Append output
             | "<<"     // Here document
             | "<&"     // Duplicate input FD
             | ">&"     // Duplicate output FD
             | "<<-"    // Here document with tab stripping
             | "&>"     // Redirect both stdout and stderr
             | "<>"     // Read/write file
             | ">|"     // Force output redirection (clobber)

redirection_list: redirection+

//------------------------------------------------------
// Simple Commands
//------------------------------------------------------
simple_command: simple_command_element+
?simple_command_element: word
                       | STRING
                       | VARIABLE
                       | CMD_SUBST
                       | ARITH_EXPR
                       | TEST_EXPR
                       | assignment_word
                       | redirection
                       | DOT

// Variable Assignment
assignment_word: word EQUAL (word | STRING | VARIABLE | CMD_SUBST | ARITH_EXPR)

//------------------------------------------------------
// Shell Commands (Complex Commands)
//------------------------------------------------------
?shell_command: if_command
              | for_command
              | while_command
              | until_command
              | select_command
              | case_command
              | subshell
              | group_command
              | function_def

// Conditional Constructs
if_command: IF compound_list THEN compound_list elif_clause* (ELSE compound_list)? FI
elif_clause: ELIF compound_list THEN compound_list

// Loop Constructs
for_command: FOR word (IN word_list)? separator? DO compound_list DONE
while_command: WHILE compound_list DO compound_list DONE
until_command: UNTIL compound_list DO compound_list DONE
select_command: SELECT word (IN word_list)? separator? DO compound_list DONE

// Case Statement
case_command: CASE (word | VARIABLE | STRING) IN case_item_list ESAC

case_item_list: (terminated_case_item)* (unterminated_case_item)?

terminated_case_item: pattern_list RPAR (compound_list)? terminator

unterminated_case_item: pattern_list RPAR (compound_list)?

pattern_list: (word | STRING | VARIABLE) (VBAR (word | STRING | VARIABLE))*

terminator: DOUBLE_SEMICOLON | ";&" | ";;&"

// Command Grouping
subshell: LPAR compound_list RPAR           // Commands executed in a subshell
group_command: LBRACE compound_list RBRACE  // Commands executed in current shell

// Function Definition
function_def: FUNCTION? word (LPAR RPAR)? group_command

//------------------------------------------------------
// Word Lists
//------------------------------------------------------
word_list: (word | STRING | VARIABLE | CMD_SUBST | ARITH_EXPR | FD)+

//------------------------------------------------------
// Command Lists and Pipelines
//------------------------------------------------------
// Compound list - sequence of commands separated by newlines or semicolons
compound_list: (separator | COMMENT)* pipeline_command ((separator | COMMENT)+ pipeline_command)* (separator | COMMENT)*

// Pipeline commands with logical operators (&&, ||)
pipeline_command: BANG? logical_sequence
logical_sequence: pipe_sequence (logical_operator pipe_sequence)*
logical_operator: LOGICAL_AND | LOGICAL_OR  // References to the tokens defined above

// Pipeline - commands connected with pipes
pipe_sequence: command (VBAR command)*

//------------------------------------------------------
// Separators
//------------------------------------------------------
separator: SEMICOLON | NEWLINE
